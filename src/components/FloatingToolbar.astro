---
/**
 * FloatingToolbar.astro - Barra de navegación flotante con controles principales
 *
 * Características:
 * - Se posiciona en la parte izquierda en desktop y en la parte inferior en móvil
 * - Se oculta automáticamente después de un período de inactividad
 * - Contiene controles para cambiar tema, activar modo desarrollador y abrir terminal
 * - Responde a eventos de usuario (hover, scroll, etc.)
 */
import { SunIcon, MoonIcon, CodeIcon, TerminalIcon } from '../icons';
---

<div class="fixed md:top-1/2 md:-translate-y-1/2 md:bottom-auto md:left-0 bottom-4 left-0 right-0 md:right-auto flex items-center justify-center md:justify-start z-40 pointer-events-none">
  <div id="floating-toolbar" class="transition-all duration-300 transform opacity-100 translate-y-0 md:translate-x-0 pointer-events-auto">
    <div class="flex md:flex-col flex-row items-center md:gap-3 gap-3 md:py-4 md:px-2 py-2 px-3 md:ml-3 mx-auto rounded-full backdrop-blur-md bg-white/40 dark:bg-dark-secondary/90 shadow-lg dark:border dark:border-gray-700/50">
      <!-- Botón para cambiar el tema -->
      <button
        id="theme-toggle"
        class="w-8 h-8 md:w-9 md:h-9 rounded-full bg-primary/10 hover:bg-primary/20 dark:bg-primary/20 dark:hover:bg-primary/30 flex items-center justify-center transition-all duration-200 hover:scale-110 active:scale-95"
        aria-label="Cambiar tema"
        title="Cambiar tema"
      >
        <!-- Icono de sol (visible en modo oscuro) -->
        <SunIcon id="theme-toggle-light-icon" class="w-4 h-4 md:w-5 md:h-5 hidden dark:block text-amber-500" />

        <!-- Icono de luna (visible en modo claro) -->
        <MoonIcon id="theme-toggle-dark-icon" class="w-5 h-5 block dark:hidden text-indigo-600" />
      </button>

      <!-- Separador (horizontal en desktop, vertical en móvil) -->
      <div class="md:w-5 md:h-px h-5 w-px bg-gray-300 dark:bg-gray-700/70"></div>

      <!-- Botón para activar el modo desarrollador -->
      <button
        id="dev-mode-toggle"
        class="w-8 h-8 md:w-9 md:h-9 rounded-full bg-primary/10 hover:bg-primary/20 dark:bg-indigo-500/20 dark:hover:bg-indigo-500/40 flex items-center justify-center transition-all duration-200 hover:scale-110 active:scale-95"
        aria-label="Activar modo desarrollador"
        title="Activar modo desarrollador"
      >
        <CodeIcon class="w-4 h-4 md:w-5 md:h-5 text-indigo-600 dark:text-indigo-300" />
      </button>

      <!-- Separador (horizontal en desktop, vertical en móvil) -->
      <div class="md:w-5 md:h-px h-5 w-px bg-gray-300 dark:bg-gray-700/70"></div>

      <!-- Botón para abrir la terminal -->
      <button
        id="terminal-toggle"
        class="w-8 h-8 md:w-9 md:h-9 rounded-full bg-primary/10 hover:bg-primary/20 dark:bg-indigo-500/20 dark:hover:bg-indigo-500/40 flex items-center justify-center transition-all duration-200 hover:scale-110 active:scale-95"
        aria-label="Abrir terminal"
        title="Abrir terminal"
      >
        <TerminalIcon class="w-4 h-4 md:w-5 md:h-5 text-indigo-600 dark:text-indigo-300" />
      </button>
    </div>
  </div>
</div>

<script>
  // Script para manejar la visibilidad de la barra según el scroll
  document.addEventListener('DOMContentLoaded', () => {
    const floatingToolbar = document.getElementById('floating-toolbar');

    if (!floatingToolbar) return;

    let lastScrollY = window.scrollY;
    const scrollThreshold = 20; // Umbral de scroll para activar la ocultación
    const inactivityDelay = 3000; // Tiempo en ms para ocultar la barra después de inactividad (3 segundos)
    let hideTimeout: number | null = null;
    let userInteracting = false;

    // Determinar si estamos en un dispositivo móvil
    const isMobile = () => window.innerWidth < 768;

    // Función para ocultar la barra (diferente en móvil y desktop)
    const hideControls = () => {
      if (isMobile()) {
        floatingToolbar.classList.remove('opacity-100', 'translate-y-0');
        floatingToolbar.classList.add('opacity-0', 'translate-y-16');
      } else {
        floatingToolbar.classList.remove('opacity-100', 'translate-x-0');
        floatingToolbar.classList.add('opacity-0', '-translate-x-16');
      }
    };

    // Función para mostrar la barra
    const showControls = () => {
      if (isMobile()) {
        floatingToolbar.classList.remove('opacity-0', 'translate-y-16');
        floatingToolbar.classList.add('opacity-100', 'translate-y-0');
      } else {
        floatingToolbar.classList.remove('opacity-0', '-translate-x-16');
        floatingToolbar.classList.add('opacity-100', 'translate-x-0');
      }

      // Configurar temporizador para ocultar después de inactividad
      resetHideTimer();
    };

    // Función para resetear el temporizador de ocultación
    const resetHideTimer = () => {
      // Limpiar el temporizador existente si hay uno
      if (hideTimeout) {
        clearTimeout(hideTimeout);
        hideTimeout = null;
      }

      // Configurar nuevo temporizador
      hideTimeout = setTimeout(() => {
        // Ocultar si no hay interacción del usuario, independientemente de la posición del scroll
        if (!userInteracting) {
          hideControls();
        }
      }, inactivityDelay) as unknown as number;
    };

    // Función para actualizar la visibilidad según el scroll
    const updateVisibility = () => {
      const currentScrollY = window.scrollY;

      // Si está en la parte superior, mostrar inicialmente pero permitir que se oculte después
      if (currentScrollY < 100) {
        showControls();
        // No hacemos return aquí para permitir que el timer de inactividad funcione
      }
      else if (Math.abs(currentScrollY - lastScrollY) > scrollThreshold) {
        // Si hay un cambio significativo en el scroll
        if (currentScrollY > lastScrollY) {
          // Scrolling hacia abajo - ocultar
          hideControls();
        } else {
          // Scrolling hacia arriba - mostrar
          showControls();
        }
        lastScrollY = currentScrollY;
      }
    };

    // Listener para el evento scroll con debounce para mejor rendimiento
    let scrollTimer: number | null = null;
    window.addEventListener('scroll', () => {
      if (scrollTimer) {
        clearTimeout(scrollTimer);
      }

      scrollTimer = setTimeout(() => {
        updateVisibility();
        resetHideTimer(); // Resetear el temporizador cuando hay scroll
      }, 10) as unknown as number;
    });

    // Detectar cuando el usuario interactúa con los controles
    floatingToolbar.addEventListener('mouseenter', () => {
      userInteracting = true;
      showControls();
    });

    floatingToolbar.addEventListener('mouseleave', () => {
      userInteracting = false;
      resetHideTimer();
    });

    // Detectar toques en dispositivos móviles
    floatingToolbar.addEventListener('touchstart', () => {
      userInteracting = true;
      showControls();
    });

    floatingToolbar.addEventListener('touchend', () => {
      userInteracting = false;
      resetHideTimer();
    });

    // También mostrar cuando el mouse se mueve por la parte izquierda de la pantalla (solo en desktop)
    document.addEventListener('mousemove', (e) => {
      if (!isMobile()) {
        const leftThreshold = 50;
        // Ya no necesitamos un límite vertical específico ya que los controles están centrados
        if (e.clientX < leftThreshold) {
          showControls();
        }
      } else {
        // En móvil, mostrar cuando el mouse se mueve por la parte inferior
        const bottomThreshold = window.innerHeight - 50;

        if (e.clientY > bottomThreshold) {
          showControls();
        }
      }
    });

    // También responder a eventos touch en la parte apropiada en móviles
    document.addEventListener('touchmove', (e) => {
      if (e.touches && e.touches[0]) {
        const touch = e.touches[0];

        if (isMobile()) {
          // En móvil, detectar toques en la parte inferior
          const bottomThreshold = window.innerHeight - 50;

          if (touch.clientY > bottomThreshold) {
            showControls();
          }
        } else {
          // En desktop, ajustamos a la posición izquierda sin límite vertical estricto
          const leftThreshold = 30;

          if (touch.clientX < leftThreshold) {
            showControls();
          }
        }
      }
    });

    // Función para manejar cambios de tamaño de pantalla
    const handleResize = () => {
      // Mostrar siempre al redimensionar para evitar problemas de visibilidad
      showControls();
    };

    // Agregar listener para redimensionamiento
    window.addEventListener('resize', handleResize);

    // Inicializar
    updateVisibility();
    resetHideTimer();
  });
</script>

<style>
  /* Estilos adicionales para efectos visuales */
  .dark #floating-toolbar > div {
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.25);
  }

  #floating-toolbar > div {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    max-width: fit-content;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  /* Optimización de rendimiento para animaciones */
  #floating-toolbar, button {
    transform: translateZ(0);
    will-change: transform, opacity;
  }

  /* Estado activo para el botón de modo desarrollador */
  #dev-mode-toggle.active-dev-mode {
    background-color: rgba(245, 158, 11, 0.3);
  }

  /* Modo oscuro para el botón activo */
  .dark #dev-mode-toggle.active-dev-mode {
    background-color: rgba(245, 158, 11, 0.5);
  }

  /* Ajustes para dispositivos móviles */
  @media (max-width: 767px) {
    #floating-toolbar > div {
      padding-left: 12px;
      padding-right: 12px;
      padding-top: 8px;
      padding-bottom: 8px;
      gap: 10px;
    }

    #floating-toolbar button {
      width: 34px;
      height: 34px;
    }

    #floating-toolbar svg {
      width: 18px;
      height: 18px;
    }
  }
</style>
