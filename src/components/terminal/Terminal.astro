---
// Terminal.astro - Componente para una terminal interactiva
import './styles.css';
---

<div id="terminal-container" class="hidden fixed bottom-4 right-4 z-50 w-96 h-80 max-w-full shadow-lg rounded-lg overflow-hidden transition-all duration-300 transform scale-95 opacity-0 pointer-events-none">
  <div class="h-full flex flex-col" style="background-color: #1f2937; color: #ffffff;">
    <!-- Barra de título de la terminal -->
    <div class="px-4 py-2 flex justify-between items-center" style="background-color: #374151;">
      <div class="text-sm font-medium" style="color: #ffffff;">Terminal</div>
      <div class="flex space-x-2">
        <button id="terminal-minimize" class="w-5 h-5 rounded-full bg-yellow-500 hover:bg-yellow-400 transition-all hover:scale-105 hover:shadow-sm active:scale-95 focus:outline-none" title="Minimizar" aria-label="Minimizar terminal">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-3 h-3 text-yellow-800">
            <path fill-rule="evenodd" d="M4 10a.75.75 0 01.75-.75h10.5a.75.75 0 010 1.5H4.75A.75.75 0 014 10z" clip-rule="evenodd" />
          </svg>
        </button>
        <button id="terminal-maximize" class="w-5 h-5 rounded-full bg-green-500 hover:bg-green-400 transition-all hover:scale-105 hover:shadow-sm active:scale-95 focus:outline-none" title="Maximizar" aria-label="Maximizar terminal">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-3 h-3 text-green-800">
            <path fill-rule="evenodd" d="M4.25 5.5a.75.75 0 00-.75.75v8.5c0 .414.336.75.75.75h8.5a.75.75 0 00.75-.75v-4a.75.75 0 011.5 0v4A2.25 2.25 0 0112.75 17h-8.5A2.25 2.25 0 012 14.75v-8.5A2.25 2.25 0 014.25 4h5a.75.75 0 010 1.5h-5z" clip-rule="evenodd" />
            <path fill-rule="evenodd" d="M6.194 12.753a.75.75 0 001.06.053L16.5 4.44v2.81a.75.75 0 001.5 0v-4.5a.75.75 0 00-.75-.75h-4.5a.75.75 0 000 1.5h2.553l-9.056 8.194a.75.75 0 00-.053 1.06z" clip-rule="evenodd" />
          </svg>
        </button>
        <button id="terminal-close" class="w-5 h-5 rounded-full bg-red-500 hover:bg-red-400 transition-all hover:scale-105 hover:shadow-sm active:scale-95 focus:outline-none" title="Cerrar" aria-label="Cerrar terminal">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-3 h-3 text-red-800">
            <path d="M6.28 5.22a.75.75 0 00-1.06 1.06L8.94 10l-3.72 3.72a.75.75 0 101.06 1.06L10 11.06l3.72 3.72a.75.75 0 101.06-1.06L11.06 10l3.72-3.72a.75.75 0 00-1.06-1.06L10 8.94 6.28 5.22z" />
          </svg>
        </button>
      </div>
    </div>

    <!-- Contenido de la terminal -->
    <div id="terminal-content" class="flex-1 p-5 overflow-y-auto font-mono text-sm terminal-text" style="background-color: #1f2937; color: #ffffff;">
      <div id="terminal-output"></div>
      <div class="terminal-input-line flex mt-2">
        <span class="terminal-text-green mr-2">$</span>
        <input
          type="text"
          id="terminal-input"
          class="flex-1 bg-transparent outline-none border-none terminal-text-white"
          style="color: #ffffff !important;"
          autocomplete="off"
          spellcheck="false"
        />
      </div>
    </div>
  </div>
</div>

<!-- Eliminar los botones flotantes que ahora estarán en FooterControls -->

<script>
  // Importar los módulos necesarios
  import {
    processCommand,
    getCommandSuggestions
  } from './commands';
  import {
    setupKonamiCodeDetector
  } from './game';
  import {
    createAppendToTerminal,
    createToggleTerminal,
    createToggleMaximize,
    makeTerminalDraggable,
    initTerminal
  } from './utils';

  document.addEventListener('DOMContentLoaded', () => {
    // Elementos del DOM
    const terminalContainer = document.getElementById('terminal-container');
    const terminalClose = document.getElementById('terminal-close');
    const terminalMinimize = document.getElementById('terminal-minimize');
    const terminalMaximize = document.getElementById('terminal-maximize');
    const terminalContent = document.getElementById('terminal-content');
    const terminalOutput = document.getElementById('terminal-output');
    const terminalInput = document.getElementById('terminal-input') as HTMLInputElement;
    const headerElement = terminalContainer?.querySelector('.px-4.py-2.flex.justify-between.items-center') as HTMLElement;

    // Obtener los botones de la barra de navegación
    const terminalToggle = document.getElementById('terminal-toggle');
    const devModeToggle = document.getElementById('dev-mode-toggle');
    const themeToggle = document.getElementById('theme-toggle');

    // Estado de la terminal
    let commandHistory: string[] = [];
    let historyIndex = -1;
    let isDevModeActive = false;
    let currentDirectory = "~";

    // Crear funciones de utilidad
    const appendToTerminal = createAppendToTerminal(terminalOutput, terminalContent);
    const toggleTerminal = createToggleTerminal(terminalContainer, terminalInput);
    const toggleMaximize = createToggleMaximize(terminalContainer);
    const isTerminalOpen = () => terminalContainer?.classList.contains('opacity-100') || false;
    const isMaximized = () => {
      // Verificar si la terminal está maximizada basado en el estilo inline
      return terminalContainer?.style.top === '80px' || false;
    };

    // Función para actualizar el título de la terminal
    const updateTerminalTitle = (maximized: boolean) => {
      const titleElement = headerElement?.querySelector('.text-sm.font-medium');
      if (titleElement) {
        titleElement.textContent = maximized ? 'Terminal (Maximizada)' : 'Terminal';
      }
    };

    // Envolver toggleMaximize para actualizar el título
    const toggleMaximizeWithTitle = () => {
      const maximized = toggleMaximize();
      updateTerminalTitle(maximized);
      return maximized;
    };

    // Hacer que la terminal sea arrastrable
    makeTerminalDraggable(terminalContainer, headerElement, isMaximized);

    // Configurar un MutationObserver para detectar cambios en el contenido de la terminal
    if (terminalOutput) {
      const observer = new MutationObserver(() => {
        if (terminalContent) {
          requestAnimationFrame(() => {
            terminalContent.scrollTop = terminalContent.scrollHeight;
          });
        }
      });

      observer.observe(terminalOutput, {
        childList: true,
        subtree: true,
        characterData: true
      });
    }

    // Función para activar/desactivar el modo desarrollador
    function toggleDevMode() {
      if (typeof window.toggleCodeEffect === 'function') {
        isDevModeActive = window.toggleCodeEffect();

        // Actualizar el aspecto del botón según el estado
        if (devModeToggle) {
          if (isDevModeActive) {
            devModeToggle.classList.add('active-dev-mode');
            devModeToggle.setAttribute('title', 'Desactivar modo desarrollador');
          } else {
            devModeToggle.classList.remove('active-dev-mode');
            devModeToggle.setAttribute('title', 'Activar modo desarrollador');
          }
        }

        // Si la terminal está abierta, mostrar un mensaje
        if (isTerminalOpen() && terminalOutput) {
          if (isDevModeActive) {
            appendToTerminal('<span class="terminal-text-green">Modo desarrollador activado.</span>', '', false);
          } else {
            appendToTerminal('<span class="terminal-text-green">Modo desarrollador desactivado.</span>', '', false);
          }
        }
      } else if (isTerminalOpen() && terminalOutput) {
        appendToTerminal('<span class="terminal-text-red">Error: El modo desarrollador no está disponible.</span>', '', false);
      }
    }

    // Función para cambiar el tema
    function toggleTheme() {
      const isDark = document.documentElement.classList.contains('dark');
      const newTheme = isDark ? 'light' : 'dark';

      if (newTheme === 'dark') {
        document.documentElement.classList.add('dark');
        localStorage.setItem('theme', 'dark');
      } else {
        document.documentElement.classList.remove('dark');
        localStorage.setItem('theme', 'light');
      }

      // Disparar evento para notificar cambio de tema
      document.dispatchEvent(new CustomEvent('themeChanged', { detail: { theme: newTheme } }));

      // Si la terminal está abierta, mostrar un mensaje
      if (isTerminalOpen() && terminalOutput) {
        appendToTerminal(`<span class="terminal-text-green">Tema cambiado a: ${newTheme}.</span>`, '', false);
      }
    }

    // Manejar el envío de comandos
    function handleCommand(command: string) {
      if (!command.trim()) return;

      // Añadir el comando al historial
      commandHistory.unshift(command);
      historyIndex = -1;

      // Procesar el comando
      const result = processCommand(
        command,
        currentDirectory,
        appendToTerminal,
        toggleTerminal,
        devModeToggle,
        isDevModeActive,
        (active) => { isDevModeActive = active; },
        terminalOutput
      );

      // Actualizar el directorio actual si cambió
      if (result.currentDirectory) {
        currentDirectory = result.currentDirectory;
      }

      // Limpiar el input
      if (terminalInput) {
        terminalInput.value = '';
      }

      // Asegurar que el scroll esté en la parte inferior después de procesar el comando
      if (terminalContent) {
        requestAnimationFrame(() => {
          terminalContent.scrollTop = terminalContent.scrollHeight;
        });
      }
    }

    // Event listeners
    terminalToggle?.addEventListener('click', toggleTerminal);
    terminalClose?.addEventListener('click', toggleTerminal);
    terminalMaximize?.addEventListener('click', toggleMaximizeWithTitle);
    terminalMinimize?.addEventListener('click', () => {
      if (isMaximized()) {
        toggleMaximizeWithTitle();
      } else {
        toggleTerminal();
      }
    });
    devModeToggle?.addEventListener('click', toggleDevMode);
    themeToggle?.addEventListener('click', toggleTheme);

    // Añadir doble clic en la barra de título para maximizar/restaurar
    headerElement?.addEventListener('dblclick', toggleMaximizeWithTitle);

    // Manejar el envío de comandos
    terminalInput?.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        const command = terminalInput.value;
        handleCommand(command);
      } else if (e.key === 'ArrowUp') {
        // Navegar hacia atrás en el historial
        if (historyIndex < commandHistory.length - 1) {
          historyIndex++;
          terminalInput.value = commandHistory[historyIndex];
          // Mover el cursor al final
          setTimeout(() => {
            terminalInput.selectionStart = terminalInput.selectionEnd = terminalInput.value.length;
          }, 0);
        }
        e.preventDefault();
      } else if (e.key === 'ArrowDown') {
        // Navegar hacia adelante en el historial
        if (historyIndex > 0) {
          historyIndex--;
          terminalInput.value = commandHistory[historyIndex];
        } else if (historyIndex === 0) {
          historyIndex = -1;
          terminalInput.value = '';
        }
        e.preventDefault();
      } else if (e.key === 'Tab') {
        // Autocompletar comandos
        e.preventDefault();
        const inputValue = terminalInput.value.trim();
        if (inputValue) {
          const suggestions = getCommandSuggestions(inputValue);
          if (suggestions.length === 1) {
            // Si hay una única sugerencia, autocompletar
            terminalInput.value = suggestions[0];
            terminalInput.selectionStart = terminalInput.selectionEnd = terminalInput.value.length;
          } else if (suggestions.length > 1) {
            // Mostrar sugerencias
            appendToTerminal('<span class="terminal-text-blue">Sugerencias:</span> ' +
              suggestions.map(s => `<span class="terminal-text-white">${s}</span>`).join(', '), '', false);

            // Asegurar que el scroll esté en la parte inferior después de mostrar sugerencias
            if (terminalContent) {
              requestAnimationFrame(() => {
                terminalContent.scrollTop = terminalContent.scrollHeight;
              });
            }
          }
        }
      }
    });

    // Enfocar el input cuando se hace clic en el contenido de la terminal
    terminalContent?.addEventListener('click', () => {
      terminalInput?.focus();
    });

    // Añadir soporte para atajos de teclado
    document.addEventListener('keydown', (e) => {
      // Ctrl+Alt+T para mostrar/ocultar la terminal
      if (e.ctrlKey && e.altKey && e.key === 't') {
        e.preventDefault();
        toggleTerminal();
      }
    });

    // Inicializar la terminal
    initTerminal(terminalOutput, terminalInput);

    // Inicializar el código Konami
    setupKonamiCodeDetector(
      toggleTerminal,
      isTerminalOpen,
      terminalInput
    );

    // Inicializar tema
    const savedTheme = localStorage.getItem('theme');
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

    if (savedTheme) {
      if (savedTheme === 'dark') {
        document.documentElement.classList.add('dark');
      } else {
        document.documentElement.classList.remove('dark');
      }
    } else {
      // Si no hay tema guardado, usar la preferencia del sistema
      if (prefersDark) {
        document.documentElement.classList.add('dark');
      } else {
        document.documentElement.classList.remove('dark');
      }
    }
  });
</script>

<style>
  /* Estilo adicional para el botón de modo desarrollador activo */
  #dev-mode-toggle.active-dev-mode {
    background-color: #f59e0b;
    box-shadow: 0 0 8px rgba(245, 158, 11, 0.5);
  }

  /* Mejora de las animaciones */
  button {
    transform: translateZ(0); /* Optimizar rendimiento de animaciones */
  }

  /* Tooltip personalizado para botones */
  button[title]:hover::after {
    content: attr(title);
    position: absolute;
    right: 100%;
    margin-right: 10px;
    padding: 4px 8px;
    border-radius: 4px;
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    font-size: 12px;
    white-space: nowrap;
    z-index: 100;
    opacity: 0;
    animation: fadeIn 0.3s forwards;
  }

  @keyframes fadeIn {
    to {
      opacity: 1;
    }
  }
</style>
